{
    "docs": [
        {
            "location": "/", 
            "text": "ErdosExtras\n\n\nA companion package for  \nErdos.jl\n graph library.\n\n\n#\n\n\nErdosExtras.solve_tsp\n \n \nFunction\n.\n\n\nsolve_tsp(g, w; cutoff=Inf)\n\n\n\n\nGiven a graph \ng\n and an edgemap \nw\n containing the weight associated to each edge, solves the Travelling Salesman Problem, returning the tour among all the cities with minimal total weight.\n\n\nEdges \ne\n with no associated value in \nw\n or with \nw[e] \n cutoff\n will not be considered for the optimal tour.\n\n\nThe algorithm uses a generic Integer Programming solver combined with a lazy constraint augmentation procedure.\n\n\nThe package JuMP.jl and one of its supported solvers are required.\n\n\nReturns a tuple \n(status, W, tour)\n containing:\n\n\n\n\na solve \nstatus\n (indicating whether the problem was solved to optimality)\n\n\nthe tototal weight \nW\n of the tour\n\n\na vector \ntour\n containing the sequence of vertices in the optimal tour.\n\n\n\n\nExample\n\n\npos = rand(30, 2)\ng = CompleteGraph(30)\nw = EdgeMap(g, e -\n norm(pos[src(e)] - pos[dst(e)]))\nstatus, W, tour = solve_tsp(g, w)\n\n\n\n\nsource\n\n\n#\n\n\nErdosExtras.minimum_weight_perfect_bmatching\n \n \nFunction\n.\n\n\nminimum_weight_perfect_bmatching(g, b[, w]; cutoff=Inf)\n\n\n\n\nGiven a graph \ng\n and an edgemap \nw\n containing the weight associated to each edge, returns the perfect \nb\n-matching with the minimum total weight.\n\n\nA perfect \nb\n-matching \nM\n is a collection of edges in \ng\n such that every vertex has exactly \nb\n incident edges in \nM\n .\n\n\nIf \nw\n is not given, all edges will be considered to have weight one (results in max cardinality b-matching).\n\n\nEdges \ne\n with no associated value in \nw\n or with \nw[e] \n cutoff\n will not be considered for the matching.\n\n\nThe algorithm uses Linear Programming to solve the linear relaxation of the problem first, then eventually refines the solution with an Integer Programming solver.\n\n\nThe efficiency of the algorithm depends on the input graph:\n\n\n\n\nIf the graph is bipartite, then the LP relaxation is integral.\n\n\nIf the graph is not bipartite, then an IP may be required to refine the solution\n\n\n\n\nand the computation time may grow exponentially.\n\n\nThe package JuMP.jl and one of its supported solvers are required.\n\n\nReturns a tuple \n(status, W, match)\n containing:\n\n\n\n\na solve \nstatus\n (indicating whether the problem was solved to optimality)\n\n\nthe tototal weight \nW\n of the matching\n\n\na vector \nmatch\n containing each vertex's \nb\n neighbors in the optimal matching.\n\n\n\n\nExample\n\n\njulia\n g = CompleteGraph(30)\njulia\n w = EdgeMap(g, e -\n rand())\njulia\n status, W, match = minimum_weight_perfect_bmatching(g, 2, w)\n\n\n\n\nsource", 
            "title": "Home"
        }, 
        {
            "location": "/#erdosextras", 
            "text": "A companion package for   Erdos.jl  graph library.  #  ErdosExtras.solve_tsp     Function .  solve_tsp(g, w; cutoff=Inf)  Given a graph  g  and an edgemap  w  containing the weight associated to each edge, solves the Travelling Salesman Problem, returning the tour among all the cities with minimal total weight.  Edges  e  with no associated value in  w  or with  w[e]   cutoff  will not be considered for the optimal tour.  The algorithm uses a generic Integer Programming solver combined with a lazy constraint augmentation procedure.  The package JuMP.jl and one of its supported solvers are required.  Returns a tuple  (status, W, tour)  containing:   a solve  status  (indicating whether the problem was solved to optimality)  the tototal weight  W  of the tour  a vector  tour  containing the sequence of vertices in the optimal tour.   Example  pos = rand(30, 2)\ng = CompleteGraph(30)\nw = EdgeMap(g, e -  norm(pos[src(e)] - pos[dst(e)]))\nstatus, W, tour = solve_tsp(g, w)  source  #  ErdosExtras.minimum_weight_perfect_bmatching     Function .  minimum_weight_perfect_bmatching(g, b[, w]; cutoff=Inf)  Given a graph  g  and an edgemap  w  containing the weight associated to each edge, returns the perfect  b -matching with the minimum total weight.  A perfect  b -matching  M  is a collection of edges in  g  such that every vertex has exactly  b  incident edges in  M  .  If  w  is not given, all edges will be considered to have weight one (results in max cardinality b-matching).  Edges  e  with no associated value in  w  or with  w[e]   cutoff  will not be considered for the matching.  The algorithm uses Linear Programming to solve the linear relaxation of the problem first, then eventually refines the solution with an Integer Programming solver.  The efficiency of the algorithm depends on the input graph:   If the graph is bipartite, then the LP relaxation is integral.  If the graph is not bipartite, then an IP may be required to refine the solution   and the computation time may grow exponentially.  The package JuMP.jl and one of its supported solvers are required.  Returns a tuple  (status, W, match)  containing:   a solve  status  (indicating whether the problem was solved to optimality)  the tototal weight  W  of the matching  a vector  match  containing each vertex's  b  neighbors in the optimal matching.   Example  julia  g = CompleteGraph(30)\njulia  w = EdgeMap(g, e -  rand())\njulia  status, W, match = minimum_weight_perfect_bmatching(g, 2, w)  source", 
            "title": "ErdosExtras"
        }
    ]
}